


----------------------------------------------------------------- MongoDB -----------------------------------------------------------------------------

-------------------------------------Lecture 1:

mongo means huge. It can store a huge amount of data.
Mongo is highly scalable & flexible, it doesn't have a structure.
We need to add fields like name, age etc. 
Key value pairs are made.

Data is stored together, less relations and it is very fast.

A database has collection ( tables ) and each collection has documents ( rows ) --> JSON Format
It is stored in JSON Format but behind the scenes it is stored in BSON format ( BSON Binary structure encodes type and length information, which allows it to be 
traversed much more quickly compared to JSON )

Nested documents are possible.

-------------------------------------Lecture 2:
Mongo installation on Windows ( already done in previous lectures)
Alongwith mongosh

-------------------------------------Lecture 3:
Mongo installation on Fedora --> Linux ( check documentation if needed )

-------------------------------------Lecture 4:
This has to be done in mongo shell
show dbs --> list all the available dbs
use <name of db> -------> it creates a database of this name if this doesn't exist

db.students.insertOne({name:"Suhaib", age:22})   -----> we don't need to write the db name again & again so we use just (db) so it knows we are in that db, we created a 
collection called students and inserted a field in JSON format too

db.students.find() -----> all documents will come. ID is unique identifier for each document


-------------------------------------Lecture 5:

Now we work on nested documents

db.students.updateOne({name:"Suhaib"}, {$set:{ idCards:{ has CNIC: true, has License: true }}})   ---------> now what does it do that it takes the first argument that
we want to change and after comma separation we set values, it will update if it's already there else it will add if it's not there, so it is adding here.
So basically students is a document and it is holding another document idCards within itself.
100 levels of nesting is possible with 16MB size of each document.

db.students.updateMany({}, {$set:{hobby:"Sports"}}) -------> if we want to update all, we left the first JSON blank and update the second JSON. We can add [] this as 
well to make an array.

db.students.find({hobby:"Sports"})   ---> Mongo will find for us all the fields with sports as hobby in it. It is smart and if you add .count(), it will give count too.
 
db.students.find({'idCards.has CNIC' : true})  ---> this is how you give query to find something in nested documents. You have to give the JSON in '' single quotations.


-------------------------------------Lecture 6:
CRUD in Mongodb.  ( create, Read, Update, Delete )

insertOne
insertMany

find
findOne

updateOne
updateMany
replaceOne

deleteOne
deleteMany


-------------------------------------Lecture 7:

db.students.find()  ---> all documents at once but it return pointer and 20 docs, because if there are million of records, it will not dump. It provides a list/array
that we can iterate over.
db.students.find({age:19})  ---> all 19 age people, filter based
db.students.findOne({age:19}) ---> only fetches the first record of all 19, order is maintained

db.students.find().count() ---> gives you numbers of records
db.students.find().forEach( (x) => {printjson(x)}) ---> You can run a loop too in Mongo and it prints entire records, prints all json.


db.students.find().limit(3) ---> it limits the records output

Remember that all these . functions return cursor there they won't work with (One) type of query

$ is a reserved keyword and only mongodb understands it..

db.students.find({age: {$lt:12} }) ---> This dumps all students with age less than 12
db.students.find({age: {$gt:12} }) ---> greater than 12
db.students.find({age: {$lt:15, $gt:10} }) ---> We have set limit here now

db.students.find().toArray() ----> only if you really wish to see all the records / documents


-------------------------------------Lecture 8:

db.students.insert({name:"Minha", age:2})
db.students.insertOne() --> only inserts one document
db.students.insertMany([{}.{}]) ---> we have to provide a list first [] and then JSON inside {} to insert many documents at once.


-------------------------------------Lecture 9:

db.students.updateOne({name:"Suhaib"},{$set:{age:15}})  ---> update is different than create and read, the first JSON is what document we want to update / basically a
filter and second JSON is actually what we want to update. It's different because a JSON is present within a JSON initiated by $set which is understood by Mongodb.

db.students.updateMany({age:12},{$set:{age:13}})  ---> this update many updates all those students who are 12 to 13.

db.students.updateMany({age:13},{$set:{isEligible: true}}) ---> all the age 13 will be updated to true eligible, as isEligible is not present, it will be created automatically.
As this key wasnot present, it will be made.

db.students.updateMany({age:{$gte:14}},{$set:{isEligible: true}})  ---> Here the filter is gte 14, all greater than equals to 14 will be set to Eligible true.


-------------------------------------Lecture 10:

db.students.deleteOne({name:"Minha"}) ---> deletes this documents.

db.students.deleteMany({})  --> All documents will be deleted.

db.students.deleteMany({age:13})  ---> All the 13 aged will be deleted.


-------------------------------------Lecture 11:
Column Query / Projection

If you want to grab certain column and not all the data you can use the filter and options in find like this:
db.students.find({},{name:1})  --->It selects all, as first JSON in empty and fetches the column of name from entire data. It will grab id as well because it is 
inclusive therefore if you need to drop that too, you can add comma separation:

db.students.find({},{name:1, _id:0}) ---> these numbers represent if we want to grab or not. 


-------------------------------------Lecture 12:

Relational Database has schema because for example if there's a table called students and it has data like name and age, if another data comes that has a separate field
like CNIC or somethings, you have to Alter entire table, entire schema is going to be changed...

BUT!!! MONGODB is schemaless, you can add or delete at any point without changing your collection or other documents. If new record comes with a new field, it will be added
for that record and rest of records remain same, no need to make any change in rest of collection.

As we know that we can add anything, therefore it can create a great mess, so at a level we have to create our own schema for our application to make it organized means
different collections. 
Schema is introduced by making ourselves, we can add related thing to one collection but not everything in just single collection.


-------------------------------------Lecture 13:

Datatypes in MongoDB.
Number, Text, Boolean, Array, ISO date, timestamp

typeof --> it can be used to check data type.

-------------------------------------Lecture 14:
To drop collections, you have to be inside that db first and then run this query.
db.dropDatabase()    -----> This deletes all the collections inside that db.

To drop just 1 collection if there are many, run this query inside db:
db.<collection name>.drop()    ---------> Only drops a specific collection


-------------------------------------Lecture 15:

insertMany(data,option)
What happens is that in insertMany everything goes in sequence, and we can give _id from our side as well, and same id return fail/false as it already exists, but what
happens is that if an object fails to go inside collection, the rest later ones and upcoming also fail due to just 1 mismatch earlier. 
Therefore we use the option in which we can provide 
ordered:false

db.books.insertMany([{_id:1, name:"A"}, {_id:2, name:"B"}, {_id:1, name:"C"}], {ordered:false})

Error will occur because of same id, but the order of sequence is not causing error and removal, the later elements will be added too.

-------------------------------------Lecture 16:

STRING VALIDATIONS!!

db.createCollection("non fiction")
db.non-fiction.insertOne({name:"ABC"})
db.non-fiction.insertOne({name:123})

Now if we check our collection, we will see both but the problem is that the name of book has to be string, not a number so we have to do string validation.

We will define validation in JSON 
db.createCollection("non-fiction",
   {validation:{
	$jsonSchema:{
		required:['name','price'],
		properties:{
			name:{
				bsonType:'string',
				description:'must be a string and required',
		},
			price:{
				bsonType:'number',
				description:'must be a string and required'
				}
			}
				}
	}, validationAction:"error" 
})

Now in future if you add any more fields, they will be added without any problem because there's no validation for it but if you want modification inside the same one,
you have to run a query like this:
db.runCommand({
collMod:'non-fiction',
validator: })    -----------------> and the changes can be made inside because rest of query looks like above.



-------------------------------------Lecture 17:



